  1: set(hyper_res).
  2: clear(back_sub).
  3: clear(demod_history).
  4: clear(print_kept).
  5: clear(print_given).
  6: assign(max_mem, 9000).
  7: assign(min_bit_width, 8).
  8: 
  9: list(usable).
 10: % Rules for building circuits.
 11: -P(x, v) | -P(y, v) | P($BIT_AND(x,y), v).
 12: -P(x, v) | -P(y, v) | P($BIT_OR(x,y), v).
 13: -P(x, v) | P($BIT_AND(11111111,$BIT_NOT(x)), append_inversion(v,x)).
 14: end_of_list.
 15: 
 16: list(sos).
 17: P(00001111, v).  % input 1
 18: P(00110011, v).  % input 2
 19: P(01010101, v).  % input 3
 20: end_of_list.
 21: 
 22: list(usable).
 23: % Denial of the goal.
 24: -P(11110000, v) | -P(11001100, v) | -P(10101010, v).
 25: end_of_list.
 26: 
 27: list(demodulators).
 28: % The following pair of demodulators inserts an element y just before the
 29: % tail-variable.
 30: append_inversion([x1|x2],y) = [x1|append_inversion(x2,y)].
 31: $VAR(x) -> append_inversion(x,y) = [y|x].
 32: end_of_list.
 33: 
 34: list(passive).
 35: % The following clause subsumes functions obtained with 3 (or more) inversions.
 36: P(x, [y1,y2,y3|y4]).
 37: end_of_list.
 38: 
 39: % The following list of weight templates gives first priority to the
 40: % goal functions, regardless of the inversion list.  Recall that with
 41: % a multiliteral denial, all of the goals must be selected as given
 42: % clauses before a proof is found by hyper.  Without these templates,
 43: % the three goals can sit on sos for a long time, delaying a proof.
 44: 
 45: weight_list(pick_given).
 46: weight(P(11110000, $(1)), -50).
 47: weight(P(11001100, $(1)), -50).
 48: weight(P(10101010, $(1)), -50).
 49: end_of_list.
